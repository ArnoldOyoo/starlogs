stages:
  - validate
  - test
  - build
  - scan
  - deploy

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
    - if: $CI_COMMIT_TAG

include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml

variables:
  AWS_REGION: "us-east-1"
  EKS_CLUSTER_NAME: "starlogs-prod"
  ECR_REPOSITORY: "starlogs-backend"
  K8S_NAMESPACE: "starlogs"
  FRONTEND_S3_BUCKET: "starlogs-prod-frontend"
  NODE_VERSION: "20"
  DOCKER_TLS_CERTDIR: ""

default:
  image: node:${NODE_VERSION}
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .npm/
      - backend/.npm/

.frontend_setup: &frontend_setup
  - npm ci --cache .npm --prefer-offline

.backend_setup: &backend_setup
  - cd backend
  - |
    if [ -f package-lock.json ]; then
      npm ci --cache .npm --prefer-offline
    else
      npm install --cache .npm --prefer-offline
    fi

terraform_validate:
  stage: validate
  image: hashicorp/terraform:1.8.5
  script:
    - terraform fmt -check -recursive
    - cd infrastructure/terraform
    - terraform init -backend=false
    - terraform validate

frontend_quality:
  stage: test
  script:
    - *frontend_setup
    - npm run lint
    - npm run build

backend_quality:
  stage: test
  script:
    - *backend_setup
    - npm run lint
    - npm run build

backend_tests:
  stage: test
  script:
    - *backend_setup
    - npm test -- --ci
  allow_failure: true

build_backend_image:
  stage: build
  image: docker:24.0.9
  services:
    - docker:24.0.9-dind
  needs:
    - frontend_quality
    - backend_quality
  before_script:
    - apk add --no-cache bash curl python3 py3-pip
    - pip3 install --no-cache-dir awscli
    - export ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
    - aws ecr describe-repositories --repository-names "${ECR_REPOSITORY}" --region "${AWS_REGION}" >/dev/null 2>&1 || aws ecr create-repository --repository-name "${ECR_REPOSITORY}" --region "${AWS_REGION}"
    - aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${ECR_REGISTRY}"
  script:
    - export IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
    - export ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
    - docker build -t "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" -t "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest" ./backend
    - docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
    - docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"
    - echo "IMAGE_TAG=${IMAGE_TAG}" >> build.env
    - echo "ECR_REGISTRY=${ECR_REGISTRY}" >> build.env
  artifacts:
    reports:
      dotenv: build.env

build_frontend_artifact:
  stage: build
  needs:
    - frontend_quality
  script:
    - *frontend_setup
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 1 day

terraform_plan:
  stage: scan
  image: hashicorp/terraform:1.8.5
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
    - when: never
  script:
    - cd infrastructure/terraform
    - terraform init
    - terraform plan -out=tfplan
    - terraform show -no-color tfplan > tfplan.txt
  artifacts:
    paths:
      - infrastructure/terraform/tfplan.txt
    expire_in: 1 day

deploy_backend_staging:
  stage: deploy
  image: amazon/aws-cli:2.17.37
  needs:
    - build_backend_image
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  before_script:
    - yum install -y tar gzip curl gettext >/dev/null
    - curl -LO "https://dl.k8s.io/release/v1.30.2/bin/linux/amd64/kubectl"
    - install -m 0755 kubectl /usr/local/bin/kubectl
    - aws eks update-kubeconfig --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}"
  script:
    - mkdir -p .rendered-k8s
    - envsubst < infrastructure/kubernetes/backend-deployment.yaml > .rendered-k8s/backend-deployment.yaml
    - envsubst < infrastructure/kubernetes/ingress.yaml > .rendered-k8s/ingress.yaml
    - kubectl apply -f infrastructure/kubernetes/namespace.yaml
    - kubectl apply -f infrastructure/kubernetes/configmap.yaml
    - kubectl apply -f .rendered-k8s/backend-deployment.yaml
    - kubectl apply -f .rendered-k8s/ingress.yaml
    - kubectl apply -f infrastructure/kubernetes/hpa.yaml
    - kubectl set image deployment/starlogs-backend backend="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" -n "${K8S_NAMESPACE}"
    - kubectl rollout status deployment/starlogs-backend -n "${K8S_NAMESPACE}" --timeout=300s
  environment:
    name: staging

deploy_backend_production:
  stage: deploy
  image: amazon/aws-cli:2.17.37
  needs:
    - build_backend_image
  rules:
    - if: $CI_COMMIT_TAG
      when: manual
    - when: never
  before_script:
    - yum install -y tar gzip curl gettext >/dev/null
    - curl -LO "https://dl.k8s.io/release/v1.30.2/bin/linux/amd64/kubectl"
    - install -m 0755 kubectl /usr/local/bin/kubectl
    - aws eks update-kubeconfig --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}"
  script:
    - mkdir -p .rendered-k8s
    - envsubst < infrastructure/kubernetes/backend-deployment.yaml > .rendered-k8s/backend-deployment.yaml
    - envsubst < infrastructure/kubernetes/ingress.yaml > .rendered-k8s/ingress.yaml
    - kubectl apply -f infrastructure/kubernetes/namespace.yaml
    - kubectl apply -f infrastructure/kubernetes/configmap.yaml
    - kubectl apply -f .rendered-k8s/backend-deployment.yaml
    - kubectl apply -f .rendered-k8s/ingress.yaml
    - kubectl apply -f infrastructure/kubernetes/hpa.yaml
    - kubectl set image deployment/starlogs-backend backend="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" -n "${K8S_NAMESPACE}"
    - kubectl rollout status deployment/starlogs-backend -n "${K8S_NAMESPACE}" --timeout=300s
  environment:
    name: production

deploy_frontend_staging:
  stage: deploy
  image: amazon/aws-cli:2.17.37
  needs:
    - build_frontend_artifact
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  script:
    - aws s3 sync dist/ "s3://${FRONTEND_S3_BUCKET}" --delete
    - |
      if [ -n "${CLOUDFRONT_DISTRIBUTION_ID}" ]; then
        aws cloudfront create-invalidation --distribution-id "${CLOUDFRONT_DISTRIBUTION_ID}" --paths "/*"
      fi
  environment:
    name: staging

deploy_frontend_production:
  stage: deploy
  image: amazon/aws-cli:2.17.37
  needs:
    - build_frontend_artifact
  rules:
    - if: $CI_COMMIT_TAG
      when: manual
    - when: never
  script:
    - aws s3 sync dist/ "s3://${FRONTEND_S3_BUCKET}" --delete
    - |
      if [ -n "${CLOUDFRONT_DISTRIBUTION_ID}" ]; then
        aws cloudfront create-invalidation --distribution-id "${CLOUDFRONT_DISTRIBUTION_ID}" --paths "/*"
      fi
  environment:
    name: production
